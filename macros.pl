#!/usr/bin/perl
#
# macros.pl   produce macros.c from standard.mac
#
# The Netwide Assembler is copyright (C) 1996 Simon Tatham and
# Julian Hall. All rights reserved. The software is
# redistributable under the license given in the file "LICENSE"
# distributed in the NASM archive.

require 'phash.ph';
require 'pptok.ph';

my $fname;
my $line = 0;
my $index      = 0;
my $tasm_count = 0;

#
# Generate macros.c
#
open(OUT,">macros.c") or die "unable to open macros.c\n";

print OUT "/*\n";
print OUT " * Do not edit - this file auto-generated by macros.pl from:\n";
print OUT " * ", join(' ', @ARGV), "\n";
print OUT " */\n";
print OUT "\n";
print OUT "#include \"tables.h\"\n";
print OUT "#include \"nasmlib.h\"\n";
print OUT "#include \"hashtbl.h\"\n";
print OUT "\n";
print OUT "const char * const nasm_stdmac[] = {";

my $npkg = 0;
my @pkg_list   = ();
my %pkg_number = ();
my %pkg_index  = ();
my $pkg;

foreach $fname ( @ARGV ) {
    open(INPUT,$fname) or die "unable to open $fname\n";
    print OUT "\n    /* From $fname */\n";
    while (<INPUT>) {
	$line++;
	chomp;
	if (m/^\s*\*END\*TASM\*MACROS\*\s*$/) {
	    $tasm_count = $index;
	    print OUT "    /* End of TASM macros */\n";
	} elsif (m/^USE:\s*(\S+)\s*$/) {
	    $pkg = $1;
	    if (defined($pkg_number{$pkg})) {
		die "$0: $fname: duplicate package: $pkg\n";
	    }
	    printf OUT "        /* %4d */ NULL,\n", $index++;
	    print OUT "    /* %use $pkg */\n";
	    push(@pkg_list, $pkg);
	    $pkg_number{$pkg} = $npkg++;
	    $pkg_index{$pkg}  = $index;
	} elsif (m/^\s*((\s*([^\"\';\s]+|\"[^\"]*\"|\'[^\']*\'))*)\s*(;.*)?$/) {
	    my $s1, $s2, $pd, $ws;
	    $s1 = $1;
	    $s1 =~ s/(\s)\s+/$1/g;
	    $s1 =~ s/\\/\\\\/g;
	    $s1 =~ s/"/\\"/g;
	    $s2 = '';
	    while ($s1 =~ /(\%[a-zA-Z_][a-zA-Z0-9_]*)((\s+)(.*)|)$/) {
		$s2 .= "$'";
		$pd = $1;
		$ws = $3;
		$s1 = $4;
		if (defined($pptok_hash{$pd}) &&
		    $pptok_hash{$pd} <= 127) {
		    $s2 .= sprintf("\\x%02x\"\"", $pptok_hash{$pd}+128);
		} else {
		    $s2 .= $pd.$ws;
		}
	    }
	    $s2 .= $s1;
	    if (length($s2) > 0) {
		printf OUT "        /* %4d */ \"%s\",\n", $index++, $s2;
	    }
	} else {
	    die "$fname:$line:  error unterminated quote";
	}
    }
    close(INPUT);
}
printf OUT "        /* %4d */ NULL\n};\n\n", $index++;
print OUT "const char * const * const nasm_stdmac_after_tasm = ",
    "&nasm_stdmac[$tasm_count];\n\n";

my @hashinfo = gen_perfect_hash(\%pkg_number);
if (!@hashinfo) {
    die "$0: no hash found\n";
}
# Paranoia...
verify_hash_table(\%pkg_number, \@hashinfo);
my ($n, $sv, $g) = @hashinfo;
die if ($n & ($n-1));

print OUT "const char * const *nasm_stdmac_find_package(const char *package)\n";
print OUT "{\n";
print OUT "    static const struct {\n";
print OUT "         const char *package;\n";
print OUT "         const char * const *macros;\n";
print OUT "    } packages[$npkg] = {\n";
foreach $pkg (@pkg_list) {
    printf OUT "        { \"%s\", nasm_stdmac+%d },\n",
	$pkg, $pkg_index{$pkg};
}
print OUT "    };\n";

# Put a large value in unused slots.  This makes it extremely unlikely
# that any combination that involves unused slot will pass the range test.
# This speeds up rejection of unrecognized tokens, i.e. identifiers.
print OUT "#define UNUSED 16383\n";

print OUT "    static const int16_t hash1[$n] = {\n";
for ($i = 0; $i < $n; $i++) {
    my $h = ${$g}[$i*2+0];
    print OUT "        ", defined($h) ? $h : 'UNUSED', ",\n";
}
print OUT "    };\n";

print OUT "    static const int16_t hash2[$n] = {\n";
for ($i = 0; $i < $n; $i++) {
    my $h = ${$g}[$i*2+1];
    print OUT "        ", defined($h) ? $h : 'UNUSED', ",\n";
}
print OUT "    };\n";

print OUT  "    uint32_t k1, k2;\n";
print OUT  "    uint64_t crc;\n";
# For correct overflow behavior, "ix" should be unsigned of the same
# width as the hash arrays.
print OUT  "    uint16_t ix;\n";
print OUT  "\n";

printf OUT "    crc = crc64i(UINT64_C(0x%08x%08x), package);\n",
    $$sv[0], $$sv[1];
print  OUT "    k1 = (uint32_t)crc;\n";
print  OUT "    k2 = (uint32_t)(crc >> 32);\n";
print  OUT "\n";
printf OUT "    ix = hash1[k1 & 0x%x] + hash2[k2 & 0x%x];\n", $n-1, $n-1;
printf OUT "    if (ix >= %d)\n", scalar(@pkg_list);
print OUT  "        return NULL;\n";
print OUT  "\n";
print OUT  "    if (nasm_stricmp(packages[ix].package, package))\n";
print OUT  "        return NULL;\n";
print OUT  "\n";
print OUT  "    return packages[ix].macros;\n";
print OUT  "}\n";

close(OUT);
